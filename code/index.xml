<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Codes on Background Process </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://backgroundprocess.com/code/</link>
    <language>en-us</language>
    <author>Tim Kuhlman</author>
    
    <updated>Mon, 01 Feb 2016 21:39:58 MST</updated>
    
    <item>
      <title>Weechat Command Queues</title>
      <link>http://backgroundprocess.com/code/weechat-queue/</link>
      <pubDate>Mon, 01 Feb 2016 21:39:58 MST</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/code/weechat-queue/</guid>
      <description>&lt;p&gt;I use &lt;a href=&#34;http://weechat.org&#34;&gt;weechat&lt;/a&gt; for much of the day and have issue regular repetitive commands periodically.
If you are in the same situation you may find the &lt;a href=&#34;https://weechat.org/scripts/source/queue.py.html/&#34;&gt;queue plugin&lt;/a&gt; I recently modified to be useful.&lt;/p&gt;

&lt;p&gt;The queue plugin simply allows you to build up a list of commands then run them all at once. My
&lt;a href=&#34;https://github.com/weechat/scripts/pull/137/files&#34;&gt;modification&lt;/a&gt; was to allow saving these across restarts of weechat.
That way I can build up a few queues I use regularily and just call them whenever needed.&lt;/p&gt;

&lt;p&gt;For example when I start my day I just execute &lt;code&gt;/qu exec morning&lt;/code&gt; to switch my away status, announce my availability in a couple of rooms, etc.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Development Best Practices for Systems Administrators</title>
      <link>http://backgroundprocess.com/code/sysadmins/</link>
      <pubDate>Sat, 16 Jan 2016 20:44:55 MST</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/code/sysadmins/</guid>
      <description>

&lt;p&gt;The days where systems administrators do no development are gone. Just as developers
leverage cloud infrastructure and tooling to deploy services, sysadmins develop code to automate
their infrastructure and to fill the feature gaps that they are uniquely positioned to see.&lt;/p&gt;

&lt;p&gt;Though best development practices are the same for both sysadmins and devs, some are more
natural to one group or another. The heart of devops is operators and developers coming together and in many ways this
post is really about what sysadmins can learn from developers. Here are some best practices I think come less naturally to operators.&lt;/p&gt;

&lt;h2 id=&#34;best-practices:321805f9cf4c4e61486b15fa3eccd686&#34;&gt;Best Practices&lt;/h2&gt;

&lt;h3 id=&#34;simplify:321805f9cf4c4e61486b15fa3eccd686&#34;&gt;Simplify&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Interface&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Make your project simple to use. Sysadmins are badasses at the CLI and forget not everyone is. Also make sure to keep the interface consistent.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Standardize&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Choose sane defaults, don&amp;rsquo;t be afraid to limit choice and flexibility so the code steers people toward good and/or standard practices.
Choice can be good at times but more often than not is a bit stifling. One difference between a usable project and a great one is often in appropriate
defaults and simplicity of configuration.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Code Structure&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Turns out the basics of code are easy, children can grasp the concepts of branches and loops. Most code is dealing with the complexity
of having so many branches and loops. That is why the common code constructs (classes, inheritance, types/interfaces) exist.
Layers of abstraction, separation of concern and encapsulation are amount the keys to good complexity management. The difference between
good design and bad is how well the complexity management is done.&lt;/p&gt;

&lt;p&gt;There are many code techniques to deal with complexity and this is a great example of where sysadmins can learn a lot from devs. I&amp;rsquo;ll not delve
into actual techniques but rather here are some principles to keep in mind while coding:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sysadvent.blogspot.com/2015/12/day-22-simplicity-in-complex-systems.html&#34;&gt;Reducing code complexity&lt;/a&gt; by thinking about where the code can shrink
or hide the complexity. Shrink complexity by building code constructs that break the complexity up. Hide it by building complexity into
methods or objects, hiding it from the rest of the system.&lt;/li&gt;
&lt;li&gt;Keep your code organized. One principle to avoid sprawling code is, &lt;a href=&#34;http://martinfowler.com/bliki/Yagni.html&#34;&gt;YAGNI&lt;/a&gt;, only write to what you
actually need now. Sysadmins run systems and so have great insight into what is needed making this best practice relatively easy. However there
is one caution with YAGNI. To quote Martin Fowler &amp;ldquo;Yagni only applies to capabilities built into the software to support a presumptive feature, it does
not apply to effort to make the software easier to modify.&amp;rdquo; In short YAGNI is not an excuse for unorganized code. Organize your code and revisit the
organization to keep it organized as it grows and more features are added.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;document:321805f9cf4c4e61486b15fa3eccd686&#34;&gt;Document&lt;/h3&gt;

&lt;p&gt;Document your code! Maybe this is one both devs and sysadmins could do better at.&lt;/p&gt;

&lt;p&gt;Document as you are writing the code. After having just written the code you know what it does and there is no better time to clearly express that.
The code&amp;rsquo;s lifecycle is just beginning, the project will be used and modified by yourself and others and good documentation helps immensely with
these further steps.&lt;/p&gt;

&lt;p&gt;The closer to the code the documentation is the better. It is most likely to stay up date if the documentation is close to the code as well as being the
easiest to find. Also being close to the code gives you an automatic context allowing the documentation to be more succinct.
Most languages have built-in tools for documenting well and publishing the docs in a standard way, use these tools.&lt;/p&gt;

&lt;p&gt;In addition to helping with the further lifecycle of your project the act of documenting is a tool for discovering unnecessarily complexity.
When documenting you have to force yourself to think like someone unfamiliar with the project which is an important mindset to adopt periodically.
This is especially true when writing the overview section of your docs which links project components together into a whole that users will interact with.
I often find documenting reveals big wins where just a bit more code results in a large improvements.&lt;/p&gt;

&lt;h3 id=&#34;test:321805f9cf4c4e61486b15fa3eccd686&#34;&gt;Test&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Automated Testing&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I find sysadmins often test manually really well but don&amp;rsquo;t automate the testing as well. The manual testing is great that first
time but the automated testing provides repeatability. The repeatability is key for proving functionality and for any future changes, which
for most projects are bound to happen.&lt;/p&gt;

&lt;p&gt;Automated testing does have its limits, in particular unit testing is limited in how useful it can be for code that interacts with other
systems. This is the type of code sysadmins write most often. It is difficult and fragile to mock out code that does network I/O, a system call, db I/O and
more network I/O. This doesn&amp;rsquo;t mean skip automated tests but rather ensure the use cases are covered with
automated integration tests. A great use of containers is to create pre-built test environments for automate integration testing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Real World Usage&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Use and run your own code in a real environment. It is through running code in a real environment that you discover the true
problems that need fixing. Indeed the motivation for much of the code sysadmins write comes from running real environments. Even though this seems
obvious to sysadmins it is a key best practices that is so important it needs to be mentioned.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Launchpad Merge Proposal Helper Script</title>
      <link>http://backgroundprocess.com/code/mp/</link>
      <pubDate>Fri, 01 Jan 2016 12:20:22 MST</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/code/mp/</guid>
      <description>&lt;p&gt;I&amp;rsquo;ve written a script to aid in merge proposals done with &lt;a href=&#34;https://launchpad.net/&#34;&gt;Launchpad&lt;/a&gt;.
Simply run the command with the url of the merge proposal as the argument and the script will
 spawn a shell with the working directory being the code with the uncommitted
merge. You can then diff the code, run tests or whatever else as needed.&lt;/p&gt;

&lt;p&gt;When you exit the shell you will be prompted to merge, if you choose to do so a commit message will be
populated for you and opened in an editor so you can edit as you choose. This is also your 2nd
opportunity to bail if you need to. Assuming all is good save and the merge will be done.&lt;/p&gt;

&lt;p&gt;The script leverages your installed credentials for bzr and will use
&lt;a href=&#34;https://help.launchpad.net/API/launchpadlib&#34;&gt;launchpadlib&lt;/a&gt; to authenticate
against the api on your first usage.&lt;/p&gt;

&lt;p&gt;The script is at &lt;a href=&#34;https://github.com/tkuhlman/scripts/blob/master/bin/mp&#34;&gt;https://github.com/tkuhlman/scripts/blob/master/bin/mp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you use &lt;a href=&#34;https://launchpad.net/&#34;&gt;Launchpad&lt;/a&gt; give it a try and let me know if it works or you have
any ideas to improve it.&lt;/p&gt;

&lt;p&gt;I should note it is bzr specific at this point as the reviews I do are primarily on bzr but it could be
extended with git support as needed.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ansible Modules</title>
      <link>http://backgroundprocess.com/code/ansible-modules/</link>
      <pubDate>Tue, 06 Jan 2015 21:43:31 -0600</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/code/ansible-modules/</guid>
      <description>

&lt;p&gt;Ansible is relatively simple in relation to other configuration management frameworks. This makes it easier to approach and accomplish real work with, especially
for those who don&amp;rsquo;t work in it full time, however there are times when more functionality is needed. Ansible&amp;rsquo;s answer for most of these situations is to
write a module.&lt;/p&gt;

&lt;p&gt;I have written a couple of &lt;a href=&#34;https://github.com/hpcloud-mon/ansible-module-monasca&#34;&gt;modules for Monasca&lt;/a&gt; and doing so was easy, particularly if you know Python.&lt;/p&gt;

&lt;h2 id=&#34;common-python-functions:452a8813491776755aef8af7303e4551&#34;&gt;Common Python Functions&lt;/h2&gt;

&lt;p&gt;Though you can write modules in any language there are various functions available for Python that simplify the process.&lt;/p&gt;

&lt;p&gt;The documentation for &lt;a href=&#34;http://docs.ansible.com/developing_modules.html&#34;&gt;writing Ansible modules&lt;/a&gt; is a bit light on some details particularly on using the
Python common functions. The docs mostly encourage you to check out code examples, my initial reaction to this was dread that things were going to get difficult.
Happily I found most of the examples were straight forward and so it was simple enough for someone already familiar with Python.&lt;/p&gt;

&lt;p&gt;The common functions make the writing of the modules in Python a simple coding task. Looking back at the modules I have written more lines are dedicated to the documentation
of the module than to the code itself. Among the code a large chunk is dealing with defining the various optional values that can be passed in. I point
this out only to highlight that the common libraries make the code and the logic itself quite simple and even naturally steer toward documentation
driven development.&lt;/p&gt;

&lt;h2 id=&#34;modules-for-idempotency:452a8813491776755aef8af7303e4551&#34;&gt;Modules for Idempotency&lt;/h2&gt;

&lt;p&gt;As I have &lt;a href=&#34;infrastructure/2014/11/02/ansible-config-management-simplified.html&#34;&gt;written previously&lt;/a&gt; loops and conditionals are cumbersome in Ansible. In my
usage I particularly felt this at times I tried to accomplish a task lacking a module and retain idempotency. Looping through a list to check the status and
then conditionally performing operations based on the result is possible in raw Ansible but is more straight forward, flexible and cleaner to implement in a
module.&lt;/p&gt;

&lt;p&gt;In Ansible a module is the fundamental mechanism used to accomplish idempotent operations. The ease of implementing idempotency in a module
verses in Ansible directly has more than anything else motivated me to add to my todo list a few modules I would like to write.&lt;/p&gt;

&lt;h2 id=&#34;shared-code-among-modules:452a8813491776755aef8af7303e4551&#34;&gt;Shared code among modules&lt;/h2&gt;

&lt;p&gt;The one major complaint I have with the modules I have written is that it is difficult to have code shared between modules. Importing python libraries is straight forward
as well as including code from the Ansible base but code shared between Ansible modules is not possible.&lt;/p&gt;

&lt;p&gt;The reason it doesn&amp;rsquo;t work is because Ansible does not execute the module locally but rather copies it to
a remote host. Additionally Ansible is trying to do this with as few operations as possible to keep it performant. Ansible would have to either parse the module
or copy the entire library directory on each run for a shared file to be available.&lt;/p&gt;

&lt;p&gt;Though I understand the reasons behind this
behaviour since Ansible handles including libraries from the Ansible core and any included python libraries in the system path are available I found myself expecting
to be able to define my own shared python files. After spending a bit of time looking for a way to have a shared python file shipped with my Ansible modules, I
choose to just copy the shared code to both Ansible modules. That is far from ideal but the amount of shared code was relatively small so the alternative of packing
it into a library to be installed on the remote machine would be more trouble.&lt;/p&gt;

&lt;p&gt;Ultimately I have no solution for this so will live with it as a minor annoyance for now.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
