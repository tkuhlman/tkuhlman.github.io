<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Lxd on Background Process </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>http://backgroundprocess.com/tags/lxd/index.xml</link>
    <language>en-us</language>
    <author>Tim Kuhlman</author>
    
    <updated>Mon, 01 Jan 0001 00:00:00 UTC</updated>
    
    <item>
      <title>Containers over VMs</title>
      <link>http://backgroundprocess.com/infrastructure/containers-over-vms/</link>
      <pubDate>Sat, 16 Apr 2016 21:06:14 MDT</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/infrastructure/containers-over-vms/</guid>
      <description>&lt;p&gt;I recently realized it has been over 6 months since I have used a VM on my workstation. Previously I
like many developers used VMs for various development tasks. The change hasn&amp;rsquo;t be in my usage of
cloud based VMs, I continue to do that as needed and appropriate. The change is that I use containers. 
I now use a mix of &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt; and &lt;a href=&#34;https://linuxcontainers.org/lxd/&#34;&gt;LXD&lt;/a&gt; for dev and
test environments and everything else I used to frequently use VMs for on my workstation. I even use containers in some
&lt;a href=&#34;http://backgroundprocess.com/systems/desktop_docker/&#34;&gt;ways&lt;/a&gt; that I haven&amp;rsquo;t used VMs.&lt;/p&gt;

&lt;p&gt;Realizing this change in my behavior is somewhat startling for me, after all VMs represented a paradigm
shift in the industry which certainly affected my workflow years ago. I previously found tools like
&lt;a href=&#34;http://backgroundprocess.com/infrastructure/vagrant/&#34;&gt;Vagrant&lt;/a&gt; a very useful part of my workflow. Nevertheless the advantages to
using containers for tasks on my personal workstation have change my workflow.&lt;/p&gt;

&lt;p&gt;Containers come with nearly all the workflow advantages that VMs do but also with additional advantages
beyond VMs:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Speed of execution - I have various aliases and scripts that launch containerized applications
and speed of startup and execution is indistinguishable from native apps.&lt;/li&gt;
&lt;li&gt;Lightweight - Not only are containers much faster than VMs they are light on resource usage so
much so that you can have many running and not notice it. I actually use signficantly less memory on my
machine than I did a year ago.&lt;/li&gt;
&lt;li&gt;Easier to share - Though possible with VMs it is just simply quicker and easier to share Docker containers.&lt;/li&gt;
&lt;li&gt;Quicker and simpler to build - The speed of startup and ease of sharing contribute to it being
really easy to startup a new container makes some changes and save it off for further use. This allows me
to nest usages, repeat test cases on different versions, etc.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The net effect is that for many uses containers just have less overhead than VMs but retain the primary advantages
that VMs brought to the industry. There are of course reasons to still use VMs on a personal workstation,
such as not running Linux as a primary OS and so lacking container support natively, doing development on the kernel,
or developing for an OS other than Linux. None of these are relevant for me so containers is the way forward on
my machines.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mojo Integration Tests with LXD</title>
      <link>http://backgroundprocess.com/code/mojo-integration-tests/</link>
      <pubDate>Fri, 12 Feb 2016 13:36:07 MST</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/code/mojo-integration-tests/</guid>
      <description>&lt;p&gt;I have recently finished building an LXD image for doing integration tests of &lt;a href=&#34;https://mojo.canonical.com&#34;&gt;Mojo&lt;/a&gt;.
I did this because I wanted to be able to reliably test the changes to Mojo that I was making. A repeatable,
standard environment that can run set of integration tests fits the bill.
&lt;/p&gt;

&lt;h2 id=&#34;using-a-container&#34;&gt;Using a Container&lt;/h2&gt;

&lt;p&gt;There are a few key advantages I see to doing the integration tests in a container image like this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Having a repeatable environment enables automation, sharing of the environment among developers, using
the environment as a base standard and incremental improvement.&lt;/li&gt;
&lt;li&gt;The image can be built to a standard, in this case it runs Ubuntu LTS with the latest distributed versions
of Juju/Mojo and other tooling.&lt;/li&gt;
&lt;li&gt;Isolation from the primary dev environment allows for easy cleanup, easier testing of various branches and tests
more easily run in parallel.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;integration-tests&#34;&gt;Integration Tests&lt;/h2&gt;

&lt;p&gt;Integration tests themselves I want running because some tests are just not practical to do via
unit tests. This is especially true for code that interacts with a lot of other programs such as Mojo.&lt;/p&gt;

&lt;p&gt;In many cases integration tests bring an real world element unit tests don&amp;rsquo;t. For example the Mojo unit tests
cover Juju interactions decently well using the expected Juju status output. However what if that
expected output changes? For example Juju output could change in a way that is harmless and not
noticed so everyone upgrades Juju, then later Mojo changes but the unit tests are all based on the
older output, integration tests will catch this before sending broken code to production.&lt;/p&gt;

&lt;p&gt;On the other hand some tests, ie proper parsing of a manifest file, work better as a unit test. In other
situations it perhaps isn&amp;rsquo;t so clear. Have integration tests as a tool in addition to unit tests gives Mojo
developers another way to validate code before merging.&lt;/p&gt;

&lt;h2 id=&#34;more-information&#34;&gt;More Information&lt;/h2&gt;

&lt;p&gt;The image can also be used for development of Mojo specs, there is some information on that and more information on using the image in the
image &lt;a href=&#34;http://bazaar.launchpad.net/~mojo-maintainers/mojo/trunk/view/head:/contrib/LXD/README.md&#34;&gt;readme&lt;/a&gt;.
I also made this &lt;a href=&#34;https://youtu.be/Q8ll7OsTtMk&#34;&gt;screen cast&lt;/a&gt; to introduce how I use the image today. I often watch
these screen casts at double speed and recommend you do for this one also.&lt;/p&gt;

&lt;p&gt;Now that the base image is done all the Mojo developers can all incrementally add more tests and I look forward to seeing it expand.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Initial impressions of lxd</title>
      <link>http://backgroundprocess.com/infrastructure/lxd/</link>
      <pubDate>Wed, 14 Oct 2015 11:04:37 MDT</pubDate>
      <author>Tim Kuhlman</author>
      <guid>http://backgroundprocess.com/infrastructure/lxd/</guid>
      <description>&lt;p&gt;In the last couple of weeks I have been taking a bit of time here and there to explore &lt;a href=&#34;http://www.ubuntu.com/cloud/tools/lxd&#34;&gt;LXD&lt;/a&gt;.
LXD is a tool for managing system containers. As both LXD and Docker deal with containers in many ways there is quite a
bit of overlap but LXD is aiming for full isolated system containers where Docker is more focused on application containers. You can even run
Docker within an LXD image. I find it helpful to think of LXD as a replacement for virtual machines.
&lt;/p&gt;

&lt;h3 id=&#34;lxd-features&#34;&gt;LXD Features&lt;/h3&gt;

&lt;p&gt;LXD is built upon &lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;LXC&lt;/a&gt; which is impressively mature when compared to most of the container ecosystem. There are some
lacking features with LXC as pointed out at &lt;a href=&#34;https://www.stgraber.org/2015/04/21/lxd-getting-started/&#34;&gt;by the project lead&lt;/a&gt;.
LXC could benefit with some things that Docker brought to the table and LXD fills these gaps:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Container images and an easy way to share them.&lt;/li&gt;
&lt;li&gt;Simpler, easier to approach tools.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to these features LXD is bringing to the table some new things, specifically:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Secure containers by default.&lt;/li&gt;
&lt;li&gt;Checkpoint/restore support to enable live migration&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;what-about-docker&#34;&gt;What about Docker&lt;/h3&gt;

&lt;p&gt;Thinking of LXD as a VM helps to clarify where it fits in a system workflow, it isn&amp;rsquo;t the entire picture. I have often thought of Docker containers
as a new style of highly specialized VMs. In fact many of the use cases where I have used Docker I have treated my container in many ways like a VM.
Though Docker is more focused on application containers and LXD on system containers there remains overlap between the two.&lt;/p&gt;

&lt;p&gt;Simple tools and most importantly easy to share and build upon images are primary reasons Docker became so popular.
This is what makes it easy to get started with Docker. Do you want to run Jenkins? With one command you can download the official image and have it running.
The ease of sharing images and building upon others is also what enables the emerging container devops deployment model. This model brings enough
advantages that has the potential to change how devops is done in the next few years.&lt;/p&gt;

&lt;p&gt;LXD is making some good progress with image sharing but it doesn&amp;rsquo;t go far enough to compete with Docker in this regard. Most notably the lack of a
public official repo with images you can build upon is missing from LXD.&lt;/p&gt;

&lt;p&gt;Though LXC is quite mature Docker has the lead as an app that wraps (or formerly wraps) LXC. With LXD it is still cumbersome to do some tasks, for
example a volume mount. Additionally there are little annoyances like the terminal columns/rows being set wrong when running bash in a container.
I expect much of this to be fixed as things mature but it is a sign that this is a new project.&lt;/p&gt;

&lt;p&gt;LXD does implement better default security in unprivileged containers, a nice feature to have. However Docker also continues to
improve in this area. LXD is also implementing live migration which I believe Docker is further behind on. This mostly seems to fit with the general
philosophy of a VM like system container versus application container.&lt;/p&gt;

&lt;h3 id=&#34;app-container-or-system-container&#34;&gt;App container or System container&lt;/h3&gt;

&lt;p&gt;In order to really think about when to use LXD and when to use Docker and how they overlap you have to explore the differences and use cases for
app container versus system containers. System containers act more like a VM with multiple processes and an init daemon. Applications containers
are leaner with no init and most often only a single service running though they aren&amp;rsquo;t limited to a single process.&lt;/p&gt;

&lt;p&gt;Today most deployed applications aren&amp;rsquo;t in any container and many companies are working on fundamentals of devops not implementing a container
based devops workflow. This migration is one area where system containers really shine, they are much easier to move an existing workflow and
applications to. In an application container without init suddenly something as basic as how you start your application changes.&lt;/p&gt;

&lt;p&gt;On the other hand a large porting of the advantages with containers are how they enable easier micro-services management and a new workflow. The
ability to not care how an image is built and to easily test the exact image that is deployed then to manage as a flexible pod with a tool like Kubernetes
are all advantages enabled by application containers.&lt;/p&gt;

&lt;p&gt;There are some use cases that won&amp;rsquo;t move to the new workflow. For example I don&amp;rsquo;t think I will ever again use a vm for development,
using a container brings the superiority of containers as well retaining the VM advantages of having a repeatable isolated dev environment. Given
the variety of tools used in development this is much better to do in a system container rather than an app container.&lt;/p&gt;

&lt;p&gt;Having all of the mature system tools at your disposal is one argument in favor of system containers. Many times saving devops time by having the
standard tools available beats the efficiency gain of a smaller image. In some cases I can easily see the initial move to containers be to a system
container with all the standard tools and later a move to a more tightly built application container.&lt;/p&gt;

&lt;p&gt;Regarding tooling it seems to me that container management tools should support both. They may have
their initial leanings simply as a way to focus development but ultimately I think system or app container is something to be decided by the use case
not by the tooling.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
